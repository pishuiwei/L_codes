1、内存可见性
	确保线程对变量的写入对其他线程是可见的。即刷新内存中的变量。
	加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作和写操作的线程都必须在同一个锁上同步。
	
2、重排序
	在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。
	
3、失效数据
	一个以及失效的值。

4、最低安全性
	当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，
	而不是一个随机的值。

5、发布对象
	“发布”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。
	如：
		将一个指向该对象的引用保存到其他代码可以访问的地方；
		在某一个非私有的方法中返回该引用；
		或者将引用传递到其他类的方法中。
		
6、逸出
	当某个不应该发布的对象发布被发布时，这种情况就被称为逸出。
	不要在构造函数中使this逸出。
	
7、外部方法
	假设有一个类C，对于C来说，“外部方法”是指行为并不完全由C来规定的方法，包括其他类中定义的方法以及类C中可以被改写的方法
	(即不是私有方法也不是终结方法)。当把一个对象传递给某个外部方法时，就相当于发布了这个对象。
	
8、线程封闭
	如果仅子单个线程内访问数据，就不需要同步。

9、Ad-hoc线程封闭
	是指维护线程封闭性的职责完全由程序实现来承担。
	
10、栈封闭
	栈封闭式线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。
	
11、ThreadLocal类
	这个类能使线程中的某个值与保存值得对象关联起来。
	
12、不可变对象
	如果某个对象在被创建后其状态及不能被修改，那么这个对象就称为不可变对象。				
	对象创建以后其状态不可修改；
	对象的所有域都是final类型；
	对象是正确创建的（在对象的构造期间，this引用没有溢出）。
	
13、不可变对象的引用
	与不可变对象之间存在着差异。
	
14、final域
	用于构造不可变性对象。
	final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。
	final域能确保初始化过程的安全性，从而可以不受限制第访问不可变对象，并在共享这些对象时无需同步。	
		
15、基本不可变对象

16、安全的发布对象
	要安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。
	一个正确构造的对象可以通过以下方式来安全地发布：
		在静态初始化化函数中初始化有个对象引用；
		将对象的引用保存到volatile类型的域或者AtomicReferance对象中；
		将对象的引用保存到某个正确构造对象的final类型域中；
		将对象的引用保存到一个由锁保护的域中。
		
17、线程安全类库的容器提供了以下的安全发布保证
	1）通过将一个键或值放入Hashtable、SynchrinizdMap或者ConcurrentMap中，可以安全地将
	它发布给任何从这些容器中访问他的线程（无论是直接访问还是通过迭代器访问）；
	
	2）通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、
	SynchronizedList或SynchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程；
	
	3）通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些
	队列中。
	
18、静态初始化
	public static Holder holder = new Holder(43);
	这种方式发布一个对象是线程安全的。
	
19、事实不可变对象
	如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为事实不可变对象。
	在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。
	
20、可变对象
	如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。
	
21、对象的发布需求取决于它的可变现
	不可变对象可以通过任意机制来发布；
	事实不可变对象必须通过安全方式来发布；
	可变对象必须通过安全方式发布，并且必须是线程安全的或者由某个锁保护起来。
	
22、在并发程序中使用和共享对象时，可以使用一些实用的策略：
	线程封闭：线程封闭的对象只能由一个线程拥有，对象被封装在该线程中，并且只能由这个线程修改；
	只读共享：在没有额外的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象；
	线程安全共享：线程安全的对象在其内部实现同步，因此对个线程可以通过对象的共有接口来进行访问而不需要进一步的同步；					
	保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。
	
	
	
	
	
	
	
	
	
			
		


		
		
	
	
	
	
	
	


	
	
	
	
	
		
	 		