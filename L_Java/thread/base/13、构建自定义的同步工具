1、Condition

2、AbstractQueuedSynchronizer
    是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易构造出来。

3、前提条件

4、依赖状态的操作可以一直阻塞直到可以继续执行，这比使他们先失败再实现起来要更为方便且更不易错误。

5、轮询

6、休眠

7、条件队列
    这个名字来源于：它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。
    传统队列的元素时一个个数据，而与之不同的是，条件队列中元素时一个个正在等待先关条件的线程。

    正如每个Java对象都可以作为一个锁，每个对象同样可以作为有个条件队列，并且Object中的wait、notify和
    notifyAll方法就构成看内部条件队列的API.

    对象的内置锁与其内部条件队列是相关联的，要调用对象X中条件队列的任何一个方法，必须持有对象X上的锁。
    这是应为“等待由状态构成的条件”与“维护状态一致性”这两种机制必须被紧密地绑定在一起：只有能对状态
    进行检查时，才能在某个条件上等待，并且只有能修改状态时，才能从条件等待中释放另一个线程。

    Object.wait会自动释放锁，并请求操作系统挂起当前线程，从而使其他线程能够获得这个锁并修改对象的状态。
    当被挂起的线程醒来时，他将在返回之前重新获取锁。
    调用wait意味着“我去休息了，但当发生特定的事件时唤醒我”，而调用通知方法就意味着“特定的事情发生了”。

8、Object
    wait
    notify
    notifyAll

9、条件谓词
    例如：队列不为空、队列满（前提条件）

10、锁对象与条件队列对象（即调用wait与notify等方法所在的对象）必须是同一个对象。

11、每一次wait调用都会隐式地与特定的条件谓词关联起来。当调用某个特定条件谓词的wait时，调用者必须已经持
    有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。

12、虽然在锁、条件谓词和条件队列之间的三元关系并不复杂，但wait方法的返回并不一定意味着线程正在等待的条件谓词
    已经变成真了。

13、丢失的信号
    线程必须等待一个已经为真的条件，但在开始等待之前没有检查条件谓词。

14、没当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知。

15、只有同时满足一下两个条件时，才能用单一的notifyAll而不是notifyAll
    所有等待线程的类型相同。只有一个条件谓词与条件队列相关，并且每个线程在从wait返回将执行相同的操作。
    单进单出。在条件变量上的每次通知，最多只能唤醒一个线程来执行。

16、在使用条件通知的时候，要想支持子类化，那么在设计类时需要保证：若歌在实施子类化时违背了条件通知或单
    次通知的某个需求，那么在子类中可以增加合适的通知机制来代表基类。
    对于状态依赖的类，要么将其等待和通知等协议完全向子类公开（并且写入正式文档），要么完全阻止子类参与
    到等待和通知等过程中。

17、入口协议和出口协议
    Wellings(Wellings,2004)通过“入口协议和出口协议”来描述wait和notify方法的正确使用。对于每个依赖状态
    的操作，以及米格修改其他操作依赖状态的操作，都应该定义一个入口协议和出口协议。
    入口协议就是该操作的条件谓词，出口协议则包括，检查被该操作修改的所有状态变量，并确认他们是否使某个其
    他的条件谓词变为真，如果是，则通知相关的条件队列。

18、显示的Condition对象
    是一种广义的条件队列。
    public interface Condition{
    void await() throws InterruptedException;
       void awaitUninterruptibly();
       long awaitNanos(long var1) throws InterruptedException;
       boolean await(long var1, TimeUnit var3) throws InterruptedException;
       boolean awaitUntil(Date var1) throws InterruptedException;
       void signal();
       void signalAll();
    }

19、每个内置锁都只能由一个相关联的条件队列，

20、如果想编写一个带有多个条件谓词的并发对象，或者想获取除了条件队列可见性之外的更多控制权，就可以使用显示的
    Lock和Condition而不是内置锁和条件队列，这是一种更灵活的选择。

21、一个Condition和一个Lock并联在一起，就像有一个条件队列和一个内置锁相关联一样。要创建一个Condition，可以在
    向关联的Lock上调用Lock.newCondition方法。
    正如Lock比内置加锁提供了更为丰富的功能，Condition同样比内置条件队列提供了更丰富的功能：在每个锁上可存在多
    个等待、条件等待可以使可中断的或者不可中断的、基于时限的等待，以及公平的或非公平的队列操作。

    与内存条件队列不同的是，对于每个Lock，可以有任意数量的Condition对象。Condition对象继承了相关的Lock对象的公
    平性，对于公平的锁，线程会依照FIFO顺序从Condition.await中释放。


    特别注意：
        在Condition对象中，与wait、notify、notifyAll方法对应的分别是await、signal和signalAll。但是Condition对
        Object进行了扩展，因而它也包含wait和notify放啊。一定要确保使用正确的版本——await和signal。


22、


















































































































