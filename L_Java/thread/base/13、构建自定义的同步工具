1、Condition

2、AbstractQueuedSynchronizer

3、前提条件

4、依赖状态的操作可以一直阻塞直到可以继续执行，这比使他们先失败再实现起来要更为方便且更不易错误。

5、轮询

6、休眠

7、条件队列
    这个名字来源于：它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。
    传统队列的元素时一个个数据，而与之不同的是，条件队列中元素时一个个正在等待先关条件的线程。

    正如每个Java对象都可以作为一个锁，每个对象同样可以作为有个条件队列，并且Object中的wait、notify和
    notifyAll方法就构成看内部条件队列的API.

    对象的内置锁与其内部条件队列是相关联的，要调用对象X中条件队列的任何一个方法，必须持有对象X上的锁。
    这是应为“等待由状态构成的条件”与“维护状态一致性”这两种机制必须被紧密地绑定在一起：只有能对状态
    进行检查时，才能在某个条件上等待，并且只有能修改状态时，才能从条件等待中释放另一个线程。

    Object.wait会自动释放锁，并请求操作系统挂起当前线程，从而使其他线程能够获得这个锁并修改对象的状态。
    当被挂起的线程醒来时，他将在返回之前重新获取锁。
    调用wait意味着“我去休息了，但当发生特定的事件时唤醒我”，而调用通知方法就意味着“特定的事情发生了”。

8、Object
    wait
    notify
    notifyAll

9、条件谓词
    例如：队列不为空、队列满（前提条件）

10、锁对象与条件队列对象（即调用wait与notify等方法所在的对象）必须是同一个对象。

11、每一次wait调用都会隐式地与特定的条件谓词关联起来。当调用某个特定条件谓词的wait时，调用者必须已经持
    有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。

12、虽然在锁、条件谓词和条件队列之间的三元关系并不复杂，但wait方法的返回并不一定意味着线程正在等待的条件谓词
    已经变成真了。

13、


















































