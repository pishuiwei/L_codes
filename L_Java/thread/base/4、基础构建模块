1、同步容器类
	Vector
	Hashtable
	Collections.synchronizedXxx
	
2、容器上常见的复合操作
	迭代（反复访问元素、直到遍历完容器中所有元素）
	跳转（根据指定顺序找到当前元素的下一个元素）
	条件运算
	
3、并发容器
	ConcurrentHashMap
	CopyOnWriteArrayList
	ConcurrentMap
	Queue
		ConcurrentLinkedQueue
		PriorityQueue
	BlockingQueue
	
4、串行线程的封闭
	
5、阻塞队列(适用于生产者--消费者模式)
	在容器类中，阻塞队列是一个独特的类：它们不仅能作为保存对象的容器，还能协调生产者和消费者等线程之间的控制流，
	因为take和put等方法将阻塞，直到队列达到期望的状态（队列即非空，也非满）。
	
6、双端队列(适用于工作密取模式)
    Deque
        ArrayDeque、LinkedBlockingDeque
    实现了在队列头和队列尾的高效插入和移除。

7、工作密取

8、分段锁

9、弱一致性

10、阻塞方法
    当代码中调用一个抛出InterruptedException异常的方法时，你自己的方法也就变成了一个阻塞方法，
    并且必须要处理对应的相应。
    BLOCKED、WAITING或TIMED _WAITING
    RUNNABLE

11、中断方法
	Thread提供了interrupt方法，用于中断线程或者查询线程是否已经被中断。
	中断时一种协议机制。
	处理对中断的相应：
		传递：避开这个异常通常是最明智的策略--只需把InterruptedException传递个调用者。传递的方法包括，
		           根本不捕获该异常，或者补货该异常，然后在执行某个简单的清理工作后再次抛出这个异常。
		回复中断：有时候不能抛出InterruptedException，必须捕获，并通过调用当前线程上的interrupt方法
				恢复中断状态，这样在调用栈中更高层的代码将看到引发了一个中断。

12、 
	线程可能会阻塞或暂停执行， 原因有很多种：等待I/O操作结束，等到获得一个锁，等待从Thread.sleep方法中醒来，
	或者等待另一个线程的计算结果。
	被阻塞的线程必须等到某个不受它控制的事件发生后才能继续执行，例如等待I/O操作完成，等待某个锁变成可用，或者等
	待外部计算的结束。
	
13、同步方法
	
14、同步工具类
	同步工具类可以是任何一个对象，只要他根据其自身的状态来协调线程的控制流。
	阻塞队列可以最为同步工具类，其他类型的同步工具类还包括信号量（Semaphore）、栅栏（Barrier）以及闭锁（Latch）。
	  	
15、闭锁
     闭锁是一种同步工具，可以延迟线程的进度知道其到达终止状态。
     闭锁的作用相当于一扇门，在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有其他任何线程能通过，
     当到达结束状态时，这扇门会打开并允许所有的线程通过。
     闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。
     闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。
	 CountDownLatch
	 FutureTask

17、信号量
    计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。
    计数信号量还可以用来实现某种资源池，或者对容器施加边界。
	Semaphore
		
18、栅栏
    栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。
    栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。
    闭锁用于等待事件，而栅栏用于等待其他线程。
	CyclicBarrier
	Exchanger		

19、FIFO: First in, First out.先进先出。

20、LIFO: Last in, First out.后进先出。
	


			
			