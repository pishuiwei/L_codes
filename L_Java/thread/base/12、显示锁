1、Lock
    与内置加锁机制不同的是，Lock提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加
    锁和解锁的方法都是显示的。
    在Lock的实现中必须提供与内部锁相同的内存可见性语义，但在加锁语义、调度算法、顺序保证以及性能特性
    等方面可以有所不同。
    public interface Lock{
        // 获取锁
        void lock();
        // 如果当前线程未被中断，则获取锁。
        void lockInterruptibly() throws InterruptedException;
        // 仅在调用时锁为空闲状态才获取该锁。
        boolean tryLock();
        //  如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。
        boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
        // 释放锁
        void unlock();
        //  返回绑定到此 Lock 实例的新 Condition 实例。
        Condition new Condition();
    }

2、ReentrantLock
      ReentrantLock并不是一种替代内置锁的方式，而是当内置锁机制不适用时，作为一种可选择的高级功能。
      ReentrantLock实了Lock接口，并提供了与synchronized相同的互斥性和内存可见性。在获取ReentrantLock
      时，有着与进入同步代码块相同的内存语义， 在释放ReentrantLock时，同样有着与退出同步代码块相同的
      内存语义。
      与synchronized一样，ReentrantLock还提供了可重入的加锁语义。
      ReentrantLock支持在Lock接口中定义的所有获取锁模式，并且与synchronized相比，它还为处理锁的不可用
      性问题提供了更高的灵活性。

3、必须在finally块中释放锁。否则。如果在被保护的代码中抛出异常，那么这个锁永远都无法释放。
    应为当程序的执行离开被保护的代码块时，不会自动清除锁。

4、轮询与定时锁
    可定时的与可轮询的锁获取模式是由tryLock方法实现的，与无条件的锁获取模式相比它具有更完善的错误恢复机制。
    在内置锁中，死锁是一个严重的问题，恢复程序的唯一方法时重新启动程序，而防止死锁的唯一方法就是在构造程序
    是避免出现不一致的锁顺序。

5、连锁式加锁（或者锁耦合）


6、公平性
    在ReentrantLock的构造函数中提供了两种公平性选择：创建一个非公平的锁（默认）或者一个公平的锁。
    在公平的锁上：线程将按照他们发出请求的顺序来获得锁，但在非公平的锁上，则允许“插队”：当一个
    线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程就将逃过队列中所有
    等待线程并获取这个锁。

7、当执行加锁操作时，公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。

8、在大多数情况下，非公平锁的性能要高于公平锁的性能。
    在竞争激烈的情况下，非公平锁的性能高于公平锁的性能的一个原因是：在恢复一个被挂起的线程与该线程真正开始
    运行之间存在着严重的延迟。

9、当持有锁的时间比较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。

10、与默认的ReentrantLock一样，内置加锁并不会提供确定的公平性保证，但在大多数情况下，在锁实现上实现统计上的
    公平性保证已经足够了。

11、在一些内置锁无法满足需求的情况下，ReentrantLock可以作为一种高级工具。当需要一些高级功能时才应该使用
    ReentrantLock,这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则
    应该优先使用synchronized。

12、ReentrantLock非块结构特性仍然意味着，获取锁的操作不能与特定的栈帧关联起来，而内置锁却可以。

13、读——写锁
    一个操作可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。

14、ReadWriteLock
    public interface ReadWriteLock{
        Lock readLock();
        Lock writeLock();
    }
    在读——写实现的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。
    对于在多处理器系统上被频繁读取的数据结构，读——写锁能够提高性能。而在其他情况下，读——写
    锁的性能比独占锁的性能要略差一些，这应为他们的复杂性更高。
    一些可选实现：
    释放优先：
        当一个写入操作释放写入锁时，并且队列中同时存在读线程和写线程，那么优先选择读线程，写写线程，
        还是线程最优先发出请求的线程？
    读线程插队：
        如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获取访问权，还是应该在写
        线程后面等待？如果允许读线程插队到写线程之前，那么将提高并发性，但却可能造成写线程发生饥饿问
        题。
    重入性：
        读取锁和写入锁是否是可重入的？
    降级：如果一个线程有写入锁，那么他能否在不释放该锁的情况下获取读取锁？这可能会使得写入锁被“降级”
        为读取锁，同时不允许其他鞋线程修改被保护的资源。
    升级：
        读取锁能否优先于其他正在等待的读线程和写线程而升级为一个写入锁？在大多数的读——写锁实现中并不
        支持升级，应为如果没有显示的升级操作，那么狠容易造成死锁。（如果两个读线程试图同时升级为写入锁，
        那么二者都不会释放读取锁。）

15、ReentrantReadWriteLock
    为这两种锁都提供了可重入的加锁语义。
    与ReentrantLock类似，ReentrantReadWriteLock在构造时也可以选择是一个非公平的锁（默认）
    还是一个公平的锁。
    在公平的锁中，等待时间最长的线程将优先获得锁。如果这个锁由读线程持有，而另一个线程请求
    写入锁，那么其他读线程都不能获取读取锁，直到写线程使用完并且释放了写入锁。
    在非公平的锁中，线程获得访问许可的顺序时不确定的。写线程降级为读线程是可以的，但从读线
    程升级为写线程则是不可以的（这样做会导致死锁）。
    与ReentrantLock类似的是，ReentrantReadWriteLock中写入锁只能有唯一的所有者，并且只能由该
    锁的线程来释放。































































































































