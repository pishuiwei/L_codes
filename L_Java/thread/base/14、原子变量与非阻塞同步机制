1、非阻塞算法
    这种算法用底层的原子机器指令（例如比较并交换指令）代替锁来确保数据咋并发访问中的一致性。
    非阻塞算法被广泛地用于在操作系统和JVM中实现JVM中实现线程/进程调度机制、垃圾回收机制以及
    锁和其他并发数据结构。

2、与基于锁的方案相比，非阻塞算法在设计和实现上都要复杂许多，但他们在可伸缩性和活跃性上却拥有
    巨大的优势。由于非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细
    的层次上进行协调，并极大地减少调度开销。而且在非阻塞涮发中不存在死锁和其他活跃性问题。
    非阻塞算法不会受到单个线程失败的影响。

3、与锁相比，volatile是一种更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换或线程调度操作。
    他们提供了相似的可见性保证，但不能用于构建原子的符合操作。
    当一个变量依赖其他变量时，或者当变量的新值依赖于旧值时，就不能使用volatile。

4、需要借助冲突检查机制来判断在更新过程中是否存在来自其他线程的干扰，如果存在，这个操作将失败，并且可
    可以重试（也可以不重试）；

5、CAS
    CAS包含了3个操作数——需要读写的内存位置V、进行比较的值A和腻拟写入的新值B。当且仅当V的值等于A时，CAS
    才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。无论位置V的值是否等于A，都将返回V原有的值（
    这种变换被为比较并设置，无论操作是否成功都会返回。）

    CAS的含义是：”我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少“。CAS
    是一项乐观的技术，它希望能成功地执行更新操作，并且如果有另一个线程在最近一次检查后更新了该变量，那么CAS
    能检查到这个错误。

6、CAS的典型使用模式是：首先从V中读取A，并根据A计算新值B，然后再通过CAS以原子方式将V中的值由A变为B(只要在这
    期间没有任何线程将V的值修改为其他值)。由于CAS能检测到来自其他线程的干扰，因此即使不使用锁也能够实现原子
    的读-改-写操作。

7、原子变量
    共有12个原子变量类。可分为4组：标量类（Scalar）、更新器类、数组类以及复合变量类，
    最常用的原子变量就是标量类：AtomicInteger、AtomicLong、AtomicBoolean以及AtomicReference。
    要想模拟其他类型的原子变量，可以将short或byte类型与int类型进行转换，以及使用floatToIntBits
    或者doubleToLongBits来转换浮点数。

8、非阻塞算法：
    如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。如果
    在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法也被称为无锁算法。如果在算法中仅将CSA用于协调线
    程之间的操作，并且能正确地实现，那么它即是一个无阻塞算法，又是一种无锁算法。
    在非阻塞算法中通常不会出现死锁和优先级反转问题（但可能会出现饥饿和活锁问题，应为在算法中会反复地从试）。

9、ABA



















