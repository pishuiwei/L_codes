3、Java应用程序无法从死锁中恢复过来，因此在设计时一定要排除那些可能导致死锁出现的条件。

4、抱死
    当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么他们将永远被阻塞。
    在线程A持有锁L并且想获取的锁M的同时，线程B持有锁M并尝试获取锁L，那么这两个线程将
    永远等待下去。

5、与许多其他并发错误一样，死锁造成的影响很少会立即显现出来。如果一个类可能发生死锁，
    那么并不意味着每次都会发生死锁，而只是表示有可能。

6、锁顺序死锁
    如果所有的线程一固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。

7、在制定锁的顺序时，可以使用System.identityHashCode(obj)方法，该方法返回由Object.hashCode
    返回的值。(186p)

8、在协作对象之间发生的死锁
    如果在持有锁的情况下调用某个外部方法，那么就需要警惕死锁。

9、开放调用
    如果在调用某个方法时不需要持有锁，那么这种调用被称为开发调用。
    依赖于开发调用的类通常能表现出更好的行为，并且与那些在调用方法时需要持有锁的类相比，也
    更易于编写。
    是同步代码块仅被保护那些涉及共享状态的操作，这样可以把方法改为开放调用。

10、在程序中应该尽量使用开放调用。与那些持有锁时间调用外部方法的程序相比。更易于对依赖开发调用
    的程序进行死锁分析。

11、资源死锁
    正如当多个线程相互持有彼此正在等待的锁而不释放自己已持有的锁时会发生死锁，当他们在相同的资源
    集合上等待时，也会发生死锁。

12、线程饥饿死锁
    一个任务提交另一个任务，并等待被提交任务在单线程的Executor中执行完成。在这种情况下，第一个任务
    永远等待下去，并使得另一个任务以及在这个Executor中执行的所有其他任务都停止。
    如果某些任务需要等待其他任务的结果，那么这些任务往往是产生线程饥饿死锁的主要来源，有界线程池/资
    源池与相互依赖的任务不能一起使用。

13、死锁的避免与诊断
    如果一个程序每次最多只能获取一个锁，那么就不会产生锁顺序死锁。（不现实）
    如果必须获取多个锁，那么在设计时必须考虑锁的顺序：尽量减少潜在的加锁交互数量，将获取锁时需要遵循的
    协议写入正式文档并始终遵守这些协议。

14、线程转储

15、单个错误并不会产生死锁，只有这两个错误同时发生时才会产生，即使他们分别进行了大量测试。


16、饥饿
    当线程由于无法访问它所需要的资源而不能继续执行时，就发生了“饥饿”
    引发饥饿的最常见资源就是CPU时钟周期。如果在Java应用程序中对线程的优先级使用不当，或者在持有锁时执行一些无法
    结束的结构（例如无限循环，或者无限制第等待某个资源），那么可能导致饥饿，因为其他需要这个锁的线程将无法得到它。
    在大多数Java程序中，所有线程都拥有相同的优先级Thread.NORM_PRIORITY。

17、活锁
    是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，应为线程将不断重复执行相同的操作，而且总
    是失败。
    活锁通常是由过度的错误恢复代码造成的，应为他错误第将不可修复作为可修复的错误。
    当对个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，具发生了或锁。


17、我们尽量不要改变线程的优先级。只要改变了线程的优先级，程序的行为就将与平台无关，并且会导致发生饥饿问题的风险。
    要避免使用线程的优先级，因为会增加平台依赖性，并可能导致活跃性问题。在大多数并发应用程序中，都可以使用默认的线
    程优先级。

18、丢失信号































