package base;

/**
 * <p>原码:将最高位作为符号位（以0代表正，1代表负）,其余各位代表数值本身的绝对值(以二进制表示),
 * 	     这个时候有一个问题：表示0的时候正0和负0表示并不一 样，所以在计算机中没有采用原码的表示形式。   
 * 	  (负数的源码是正数源码最高位变为1) 
 * <p>反码:一个数如果为正，则它的反码与原码相同；一个数如果为负，则符号位为1，其余各位是对原码取反。
 *    问题和上面一样的。所以，计算机中也没有采用反码来表示数 字。 
 * <p>补码: 一个数如果为正，则它的原码、反码、补码相同；一个数如果为负，则符号位为1，其余各位是
 *    对原码取反,然后再加1。也就是通过将与其对应的正数的二进制代 码取反(即将1变成0，将0变成1),然后
 *    对其结果加1。例如，-42就是通过将42的二进制代码的各个位取反，即对00101010 取反得到11010101,
 *    然后再加1，得到11010110 ，即-42 。要对一个负数解码，首先对其所有的位取反，然后加1。
 *    例如-42，或11010110 取反后为00101001 ，或41，然后加1，这样就得到了42。
 * 
 * <p>按位'与' &, 如果参加运算的两个数都是1,则输出1,否则输出0;
 * <p>按位'或' |, 只要有一位是1就输出1,否则输出0;
 * <p>按位'异或' ^, 两个输出位相同输出0,不相同输出1;
 * <p>按位'非' ~, 也称为去翻操作,只对一个操作数进行运算,如果1则取0,0则取1;(负数减1变正数，正数加1变负数)
 * 
 * <p>移位操作符,只能处理整数类型
 * <p>左移位 '<<', 按照操作符右侧指定的位数将操作符左边的操作数向左移动,在低位补0
 * <p>有符号右移位'>>', 按照操作符右侧指定的位数将操作符左边的操作数向右移动,符号为正,在高位插入0;为负,高位插入1
 * <p>无符号右移操作 >>>, 无论正负都在高位插入0 
 * 
 * @author PP
 *
 */
public class BitDemo {
	public static void main(String[] args) {
		int i = 128;
		int j = 129;
		System.out.println(i&j);
	}
}

/**
 * 
 */











