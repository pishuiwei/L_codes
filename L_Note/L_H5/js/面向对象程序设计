+理解对象
	属性类型:
		数据属性
			[[Configurable]]：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特
				性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的
				这个特性默认值为true。
			[[Enumerable]]：表示能否通过for-in 循环返回属性。像前面例子中那样直接在对象上定
				义的属性，它们的这个特性默认值为true。
			[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的
				这个特性默认值为true。
			[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，
				把新值保存在这个位置。这个特性的默认值为undefined。
			var person = {};
			Object.defineProperty(person, "name", {
				writable: false,
				value: "Nicholas"
			});
		访问器属性
		 [[Get]]：在读取属性时调用的函数。默认值为undefined。
		 [[Set]]：在写入属性时调用的函数。默认值为undefined。
		定义多个属性
		var book = {};
		Object.defineProperties(book, {
			_year: {
				value: 2004
			},
			edition: {
				value: 1
			}
		}	
		读取属性的特性
			var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
			alert(descriptor.value);
			alert(descriptor.configurable);
+创建对象
	工厂模式:
		function createPerson(name, age, job){
			var o = new Object();
				o.name = name;
				o.age = age;
				o.job = job;
				o.sayName = function(){
				alert(this.name);
			};
			return o;
		}
		var person1 = createPerson("Nicholas", 29, "Software Engineer");
		var person2 = createPerson("Greg", 27, "Doctor");
	构造函数模式:			
		function Person(name, age, job){
			this.name = name;
			this.age = age;
			this.job = job;
			this.sayName = function(){
				alert(this.name);
			};
		}
		var person1 = new Person("Nicholas", 29, "Software Engineer");
		var person2 = new Person("Greg", 27, "Doctor");				
	原型模式:			
		function Person(){}
		Person.prototype.name = "Nicholas";
		Person.prototype.age = 29;
		Person.prototype.job = "Software Engineer";
		Person.prototype.sayName = function(){
			alert(this.name);
		};
		var person1 = new Person();
		person1.sayName(); //"Nicholas"
		var person2 = new Person();
		person2.sayName(); //"Nicholas"
		alert(person1.sayName == person2.sayName); //true
		
		function Person(){}
		Person.prototype = {
			constructor : Person,
			name : "Nicholas",
			age : 29,
			job: "Software Engineer",
			sayName : function () {
				alert(this.name);
			}
		};
	组合使用构造函数模式和原型模式:
	动态原型模式:
		function Person(name, age, job){
			//属性
			this.name = name;
			this.age = age;
			this.job = job;
			//方法
			if (typeof this.sayName != "function"){
				Person.prototype.sayName = function(){
					alert(this.name);
				};
			}
		}
		var friend = new Person("Nicholas", 29, "Software Engineer");
		friend.sayName();	
	寄生构造函数模式:	
		function Person(name, age, job){
			var o = new Object();
			o.name = name;
			o.age = age;
			o.job = job;
			o.sayName = function(){
				alert(this.name);
			};
			return o;
		}
		var friend = new Person("Nicholas", 29, "Software Engineer");
		friend.sayName(); //"Nicholas"
	稳妥构造函数模式:
		function Person(name, age, job){
			//创建要返回的对象
			var o = new Object();
			//可以在这里定义私有变量和函数
			//添加方法
			o.sayName = function(){
				alert(name);
			};
			//返回对象
			return o;
		}
+继承
	原型链:
		function SuperType(){
			this.property = true;
		}
		SuperType.prototype.getSuperValue = function(){
				return this.property;
		};
		function SubType(){
			this.subproperty = false;
		}
		//继承了SuperType
		SubType.prototype = new SuperType();
		SubType.prototype.getSubValue = function (){
			return this.subproperty;
		};
		var instance = new SubType();
		alert(instance.getSuperValue()); //true
	借用构造函数:
		function SuperType(){
			this.colors = ["red", "blue", "green"];
		}
		function SubType(){
			// 继承了SuperType
			SuperType.call(this);
		}
		var instance1 = new SubType();
		instance1.colors.push("black");
		alert(instance1.colors); // "red,blue,green,black"
		var instance2 = new SubType();
		alert(instance2.colors); // "red,blue,green"
	组合继承:结合原型链和借用构造函数
	原型式继承：
		// 可以使用Object.create(person);替换object
		function object(o){
			function F(){}
			F.prototype = o;
			return new F();
		}
		var person = {
			name: "Nicholas",
			friends: ["Shelby", "Court", "Van"]
		};
		var anotherPerson = object(person);
		anotherPerson.name = "Greg";
		anotherPerson.friends.push("Rob");
		var yetAnotherPerson = object(person);
		yetAnotherPerson.name = "Linda";
		yetAnotherPerson.friends.push("Barbie");
		alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"
	寄生式继承:
		function createAnother(original){
			var clone = object(original); //通过调用函数创建一个新对象
			clone.sayHi = function(){ //以某种方式来增强这个对象
				alert("hi");
			};
			return clone; //返回这个对象
		}
		var person = {
			name: "Nicholas",
			friends: ["Shelby", "Court", "Van"]
		};
		var anotherPerson = createAnother(person);
		anotherPerson.sayHi(); //"hi"	
	寄生组合式继承:
		function inheritPrototype(subType, superType){
			var prototype = object(superType.prototype); //创建对象
			prototype.constructor = subType; //增强对象
			subType.prototype = prototype; //指定对象
		}
		function SuperType(name){
			this.name = name;
			this.colors = ["red", "blue", "green"];
		}
		SuperType.prototype.sayName = function(){
		alert(this.name);
		};
		function SubType(name, age){
			SuperType.call(this, name);
			this.age = age;
		}
		inheritPrototype(SubType, SuperType);
		SubType.prototype.sayAge = function(){
			alert(this.age);
		};
		
		
		
		